//Pins generated by a system builder, but structural code written by JUNAID CHATOOR
//============================================================================
// comb_ckt_generator.v
//
// This code is generated by Terasic System Builder
// and modified by M. Hildebrand and B. Baas
//
// 2018/02/05 First version
// 2018/04/24 Routed all board-level switches and LEDs to and from this module
//============================================================================

module comb_ckt_generator (
   // VGA-related signals
	reset,
	VGA_VS,
	clk,
   col,
   row,
   red,
   green,
   blue,
   // input push buttons and switches
   KEY,
   SW,
   // output LEDs and 7-segment displays
   LEDR,
   HEX0,
   HEX1,
   HEX2,
   HEX3,
   HEX4,
   HEX5
   );
input reset;
input         VGA_VS;
input 		  clk;
input  [9:0]  col;
input  [8:0]  row;
output [3:0]  red;    // 4-bit color output
output [3:0]  green;  // 4-bit color output
output [3:0]  blue;   // 4-bit color output

// input push buttons and switches
input  [1:0]  KEY;    // two board-level push buttons KEY1 - KEY0
input  [9:0]  SW;     // ten board-level switches SW9 - SW0

// output LEDs and 7-segment displays
output [9:0]  LEDR;   // ten board-level LEDs LEDR9 - LEDR0
output [7:0]  HEX0;   // board-level 7-segment display
output [7:0]  HEX1;   // board-level 7-segment display
output [7:0]  HEX2;   // board-level 7-segment display
output [7:0]  HEX3;   // board-level 7-segment display
output [7:0]  HEX4;   // board-level 7-segment display
output [7:0]  HEX5;   // board-level 7-segment display


//============================================================================
//  reg/wire declarations
//============================================================================
// More complex implementations will likely declare RGB outputs as regs
// rather than wires
reg [3:0]    red, green, blue;    //declared by Junaid Chatoor


//============================================================================
// Board-LED related circuits
//============================================================================

// Temporary simple logic
// The 10 LEDs will light depending on the position of the adjacent 10 switches
assign LEDR = SW;      // ten LEDs assigned to ten switches

// Temporary simple logic
// This block sets the 7-segment HEX displays
// HEX4 - HEX0 are set to all dark
// HEX5 lights segments based on SW9 - SW2
assign HEX0 = 8'b1111_1111;
assign HEX1 = 8'b1111_1111;
assign HEX2 = 8'b1111_1111;
assign HEX3 = 8'b1111_1111;
assign HEX4 = 8'b1111_1111;
assign HEX5 = 8'b1111_1111;


//==============================================================
// VGA display related circuits
//==============================================================
//////////////////////////Written by JUNAID CHATOOR/////////////////////////////////
//ROM adders
reg [17:0] romadd_r;
reg [17:0] adder;

//RGB variables
wire [11:0] data1,data2,data3,data4;

//col and row registers
reg [9:0] colreg, colreg1, colreg2, colreg3;
reg [8:0] rowreg, rowreg1, rowreg2, rowreg3;

//falling VGA variables
reg vga_vs_sync_1, vga_vs_sync_2;
wire vga_negedge;

//Display Mode variables
reg [1:0] show;
reg true;

// luna parameters 
reg [19:0] redgrey;
reg [19:0] bluegrey;
reg [19:0] greengrey;
reg [29:0] luma;

// pixel buffer
reg [11:0] pixbuff [3:0];

//Negedge VGA has to be true when sync 2 is high and sync 1 is low
assign 	vga_negedge=vga_vs_sync_2 && (!vga_vs_sync_1);	

//Sync registers to control timing
always@(posedge clk) begin
	if (reset) begin
	rowreg <= 0;
	colreg <= 0;
	
	rowreg1 <= 0;
	rowreg2 <= 0;
	rowreg3 <= 0;
	
	colreg1 <= 0;
	colreg2 <= 0;
	colreg3 <= 0;	
	end else begin
	rowreg <= row;
	colreg <= col;
	
	rowreg1 <= rowreg;
	rowreg2 <= rowreg1;
	rowreg3 <= rowreg2;
	
	colreg1 <= colreg;
	colreg2 <= colreg1;
	colreg3 <= colreg2;
	end
	
end

always@(posedge clk)begin
  show <= SW[9:8]; 
   //VGA falling frame updates	
//	vga_vs_sync_1<=VGA_VS;
//   vga_vs_sync_2<=vga_vs_sync_1; 
//	
//	//Display only at negedge VGA
//	if(vga_negedge==1'b1 /*&& ~SW[0]*/) begin
//		show<=SW[9:8];
//	end else begin
//		show<=show;
//	end
	
	//Display regions
	case(show)
		2'b00: 
		begin
			if ((rowreg >= 0 && rowreg <= 127) && (colreg >= 0 && colreg <= 127)) begin
				true = 1'b1;
			end else if (((rowreg >= 128 && rowreg <= 479) && (colreg >= 0 && colreg <= 639)) || ((rowreg >= 0 && rowreg <= 479) && (colreg >= 128 && colreg <= 639))) begin
				true = 1'b0;
			end
		end
		2'b01: 
		begin
			if ((rowreg >= 0 && rowreg <= 255) && (colreg >= 0 && colreg <= 255)) begin
				true = 1'b1;
			end else if (((rowreg >= 256 && rowreg <= 479) && (colreg >= 0 && colreg <= 639)) || ((rowreg >= 0 && rowreg <= 479) && (colreg >= 256 && colreg <= 639))) begin
				true = 1'b0;
			end
		end
		2'b10: 
		begin
			if ((rowreg >= 0 && rowreg <= 383) && (colreg >= 0 && colreg <= 383)) begin
				true = 1'b1;
			end else if (((rowreg >= 384 && rowreg <= 479) && (colreg >= 0 && colreg <= 639)) || ((rowreg >= 0 && rowreg <= 479) && (colreg >= 384 && colreg <= 639))) begin
				true = 1'b0;
			end
		end
		2'b11: 
		begin
			if ((rowreg >= 0 && rowreg <= 479) && (colreg >= 0 && colreg <= 511)) begin
				true = 1'b1;
			end else if (((rowreg >= 0 && rowreg <= 479) && (colreg >= 128 && colreg <= 639))) begin
				true = 1'b0;
			end
		end	
	endcase
end

always @ (posedge clk) begin

	//Rom data collection
	if (true && show == 2'b00) begin
		adder <= ((rowreg*128) + colreg) ;
	end else if (true && show == 2'b01) begin
		adder <= ((rowreg>>1)*256) + colreg ;
	end else if (true && show == 2'b10) begin
		adder <= ((rowreg/3)*384) + colreg ;
	end else if (true && show == 2'b11) begin
		adder <= ((rowreg>>2)*512) + colreg ;
	end

	//Image scaling/stretching
	if (true && show == 2'b00) begin
		romadd_r <= adder;
	end else if (true && show == 2'b01) begin
		romadd_r <= adder[14:1];
	end else if (true && show == 2'b10) begin
		romadd_r <= adder/3;
	end else if (true && show == 2'b11) begin
		romadd_r <= adder>>2;
	end
	
	//Rom address selection to the pixel buffer
	if (true) begin
	if (romadd_r >= 0 && romadd_r <= 4095) begin
		pixbuff[0] <= data1;
		pixbuff[1] <= pixbuff[0];
		pixbuff[2] <= pixbuff[1];
		pixbuff[3] <= pixbuff[2];
	end else if (romadd_r >= 4096 && romadd_r <= 8191) begin
		pixbuff[0] <= data2;
		pixbuff[1] <= pixbuff[0];
		pixbuff[2] <= pixbuff[1];
		pixbuff[3] <= pixbuff[2];
	end else if (romadd_r >= 8192 && romadd_r <= 12287) begin
		pixbuff[0] <= data3;
		pixbuff[1] <= pixbuff[0];
		pixbuff[2] <= pixbuff[1];
		pixbuff[3] <= pixbuff[2];
	end else if (romadd_r >= 12288 && romadd_r <= 16383) begin
		pixbuff[0] <= data4;
		pixbuff[1] <= pixbuff[0];
		pixbuff[2] <= pixbuff[1];
		pixbuff[3] <= pixbuff[2];
	end else begin
		pixbuff[0] <= 12'd0;
		pixbuff[1] <= 12'd0;
		pixbuff[2] <= 12'd0;
		pixbuff[3] <= 12'd0;
	end
	end
	
end

always@(*)begin

//	if (reset) begin
//		red = 4'b0000;
//		blue = 4'b0000;
//		green = 4'b0000;
//	end else begin

	//Extra Credit
	if (SW[0]) begin
		if ((colreg >= 0 && colreg <= 159) && (rowreg >= 0 && rowreg <= 479)) begin
			red = 4'b1111;
			blue = 4'b0000;
			green = 4'b1111;
		end if ((colreg >= 160 && colreg <= 319) && (rowreg >= 0 && rowreg <= 479))	begin
			red = 4'b0000;
			blue = 4'b1111;
			green = 4'b1111;
		end if ((colreg >= 320 && colreg <= 479) && (rowreg >= 0 && rowreg <= 479)) begin
			red = 4'b1111;
			blue = 4'b1111;
			green = 4'b0000;
		end if ((colreg >= 480 && colreg <= 639) && (rowreg >= 0 && rowreg <= 479)) begin
			red = 4'b0000;
			blue = 4'b0000;
			green = 4'b1111;
		end
	end else begin
			
	//Zoom selection
	if(true && show == 2'b00)begin
		red = pixbuff[0][3:0];
		blue = pixbuff[0][7:4];
		green = pixbuff[0][11:8];
	end else if(true && show == 2'b01)begin
		red = pixbuff[1][3:0];
		blue = pixbuff[1][7:4];
		green = pixbuff[1][11:8];
	end else if(true && show == 2'b10)begin
		red = pixbuff[2][3:0];
		blue = pixbuff[2][7:4];
		green = pixbuff[2][11:8];
	end else if(true && show == 2'b11)begin
		red = pixbuff[3][3:0];
		blue = pixbuff[3][7:4];
		green = pixbuff[3][11:8];
	end 
	
	//RGB & Greyscale logic
	if (SW[4]) begin  
	//Greyscale for decimals multiply by 16384
		redgrey = 3483 * pixbuff[0][3:0];  //0.2126
		bluegrey = 11718 * pixbuff[0][7:4];  //0.7152
		greengrey = 1183 * pixbuff[0][11:8];  //0.0722
		//Shift 2^14 to accomodate for 16384
		luma = (redgrey + bluegrey + greengrey) >> 14; 
		red = luma;
		blue = luma;
		green = luma;
	end else if (~SW[4]) begin  
	//RGB control
	if ((SW[7:5] == 3'b000)) begin
			red = pixbuff[0][3:0];
			blue =  pixbuff[0][7:4];
			green = pixbuff[0][11:8];
	end else if ((SW[7:5] == 3'b001)) begin
			red = pixbuff[0][3:0];
			blue = 4'b0000;
			green = pixbuff[0][11:8];
	end else if ((SW[7:5] == 3'b010)) begin
			red = pixbuff[0][3:0];
			blue = pixbuff[0][7:4];
			green = 4'b0000;	
	end else if ((SW[7:5] == 3'b100)) begin
			red = 4'b0000;
			blue = pixbuff[0][7:4];
			green = pixbuff[0][11:8];
	end else if ((SW[7:5] == 3'b011)) begin
			red = pixbuff[0][3:0];
			blue = 4'b0000;
			green = 4'b0000;
	end else if ((SW[7:5] == 3'b111)) begin
			red = 4'b0000;
			blue = 4'b0000;
			green = 4'b0000;	
	end else if ((SW[7:5] == 3'b101)) begin
			red = 4'b0000;
			blue = 4'b0000;
			green = pixbuff[0][11:8];
	end else if ((SW[7:5] == 3'b110)) begin
			red = 4'b0000;
			blue = pixbuff[0][7:4];
			green = 4'b0000;	
	end
	end
	
	//Region outside picture turned black
	if (show == 2'b00) begin
		if (((rowreg3 >= 128 && rowreg3 <= 479) && (colreg3 >= 0 && colreg3 <= 639)) || ((rowreg3 >= 0 && rowreg3 <= 479) && (colreg3 >= 128 && colreg3 <= 639))) begin
			red = 4'b0000;
			blue = 4'b0000;
			green = 4'b0000;
		end	
	end else if (show == 2'b01) begin
		if (((rowreg3 >= 256 && rowreg3 <= 479) && (colreg3 >= 0 && colreg3 <= 639)) || ((rowreg3 >= 0 && rowreg3 <= 479) && (colreg3 >= 256 && colreg3 <= 639))) begin
			red = 4'b0000;
			blue = 4'b0000;
			green = 4'b0000;
		end
	end else if (show == 2'b10) begin
		if (((rowreg3 >= 384 && rowreg3 <= 479) && (colreg3 >= 0 && colreg3 <= 639)) || ((rowreg3 >= 0 && rowreg3 <= 479) && (colreg3 >= 384 && colreg3 <= 639))) begin
			red = 4'b0000;
			blue = 4'b0000;
			green = 4'b0000;
		end
	end else if (show == 2'b11) begin
		if (((rowreg3 >= 0 && rowreg3 <= 479) && (colreg3 >= 512 && colreg3 <= 639))) begin
			red = 4'b0000;
			blue = 4'b0000;
			green = 4'b0000;
		end
	end 
		
	end
//	end
end


//RED
rom_0 r0(
	.clock (clk),
	.address (romadd_r[11:0]),
	.data_out (data1[3:0])
);

rom_1 r1(
	.clock (clk),
	.address (romadd_r[11:0]),
	.data_out (data2[3:0])
);

rom_2 r2(
	.clock (clk),
	.address (romadd_r[11:0]),
	.data_out (data3[3:0])
);

rom_3 r3(
	.clock (clk),
	.address (romadd_r[11:0]),
	.data_out (data4[3:0])
);

//BLUE
rom_4 r4(
	.clock (clk),
	.address (romadd_r[11:0]),
	.data_out (data1[7:4])
);

rom_5 r5(
	.clock (clk),
	.address (romadd_r[11:0]),
	.data_out (data2[7:4])
);

rom_6 r6(
	.clock (clk),
	.address (romadd_r[11:0]),
	.data_out (data3[7:4])
);

rom_7 r7(
	.clock (clk),
	.address (romadd_r[11:0]),
	.data_out (data4[7:4])
);

//GREEN
rom_8 r8(
	.clock (clk),
	.address (romadd_r[11:0]),
	.data_out (data1[11:8])
);

rom_9 r9(
	.clock (clk),
	.address (romadd_r[11:0]),
	.data_out (data2[11:8])
);

rom_10 r10(
	.clock (clk),
	.address (romadd_r[11:0]),
	.data_out (data3[11:8])
);

rom_11 r11(
	.clock (clk),
	.address (romadd_r[11:0]),
	.data_out (data4[11:8])
);
		
		
endmodule
